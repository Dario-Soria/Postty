import type { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import * as logger from '../utils/logger';
import * as path from 'path';
import * as fs from 'fs/promises';
import { sendMessageToAgent, ensureAgentRunning } from '../services/productShowcaseAgent';

interface AgentChatBody {
  agentType: string;
  message: string;
  conversationHistory?: string;
}

export default async function agentChatRoute(fastify: FastifyInstance): Promise<void> {
  fastify.post('/agent-chat', async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      // Extract form fields
      const fields: Record<string, any> = {};
      let imageFile: { filename: string; path: string } | null = null;

      // Process all parts using multipart iterator
      const parts = request.parts();
      for await (const part of parts) {
        if (part.type === 'field') {
          fields[part.fieldname] = part.value;
        } else if (part.type === 'file' && part.fieldname === 'image') {
          // Save uploaded image to temp folder
          const tempDir = path.join(process.cwd(), 'temp-uploads');
          await fs.mkdir(tempDir, { recursive: true });
          
          const filename = `agent-upload-${Date.now()}-${part.filename}`;
          const filepath = path.join(tempDir, filename);
          
          await fs.writeFile(filepath, await part.toBuffer());
          imageFile = { filename, path: filepath };
        }
      }

      const { agentType, message, conversationHistory, userId } = fields;

      if (!agentType) {
        return reply.status(400).send({
          status: 'error',
          message: 'Missing required field: agentType',
        });
      }

      // Allow empty message if image is provided
      if (message === undefined && !imageFile) {
        return reply.status(400).send({
          status: 'error',
          message: 'Missing required field: message (or provide an image)',
        });
      }

      // Only support product-showcase for now
      if (agentType !== 'product-showcase') {
        return reply.send({
          type: 'text',
          text: 'Este agente aún no está disponible. Próximamente.',
        });
      }

      // Allow client-provided sessionId (used to force a true "start over" / fresh run)
      const clientSessionIdRaw = fields.sessionId;
      const clientSessionId =
        typeof clientSessionIdRaw === 'string' && clientSessionIdRaw.trim()
          ? clientSessionIdRaw.trim()
          : undefined;

      // Extract userId with fallback for backward compatibility
      const sessionId =
        clientSessionId || userId || `anon-${Date.now()}-${Math.random().toString(36).substring(7)}`;
      logger.info(`[Agent Chat] Session ID: ${sessionId.substring(0, 12)}...`);

      // Ensure the Python agent process is running
      logger.info(`[Agent Chat] Ensuring agent is running...`);
      await ensureAgentRunning();

      // If message is empty but image is provided, use a placeholder
      const messageToSend = message || (imageFile ? "" : "");

      // Send message to Python agent with image path and session ID
      logger.info(`[Agent Chat] Sending message: "${messageToSend}", image: ${imageFile?.path || 'none'}`);
      const result = await sendMessageToAgent(messageToSend, imageFile?.path, sessionId);
      logger.info(`[Agent Chat] Received result type: ${result.type}`);

      // Handle different response types
      if (result.type === 'reference_options') {
        // Reference images are being presented to user
        return reply.send({
          type: 'reference_options',
          text: result.text,
          references: result.references,
        });
      }
      
      if (result.type === 'image' && result.file) {
        // Image was generated by pipeline, file path is already absolute
        // Extract just the filename for the URL
        const filename = path.basename(result.file);
        
        // Return full backend URL so frontend can access it
        const backendUrl = process.env.BACKEND_URL || 'http://localhost:8080';
        
        const response: any = {
          type: 'image',
          text: result.text,
          imageUrl: `${backendUrl}/generated-images/${filename}`,
        };
        
        // Include textLayout if present
        if (result.textLayout) {
          response.textLayout = result.textLayout;
        }
        
        return reply.send(response);
      }

      // Text response
      return reply.send({
        type: 'text',
        text: result.text,
      });

    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Unknown error';
      logger.error('Agent chat error:', errorMsg);
      
      return reply.status(500).send({
        status: 'error',
        message: 'Error communicating with agent',
        details: errorMsg,
      });
    }
  });

  logger.info('✅ Agent chat route registered: POST /agent-chat');
}

